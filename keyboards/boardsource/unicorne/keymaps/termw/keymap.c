#include QMK_KEYBOARD_H
#include "g/keymap_combo.h"

#define ANIM_INVERT false
#define ANIM_RENDER_WPM true
#define FAST_TYPE_WPM 40 //Switch to fast animation when over words per minute
#ifdef OLED_ENABLE
#include "lib/oled.h"
#include "demon.c"
#endif

#define _BASE 0
#define _GAME 1
#define _NAV 2
#define _MOUSE 3
#define _SYS 4

// Custom keycodes
enum custom_keycodes {
    // M_UPDIR = SAFE_RANGE,
    VI_WQA = SAFE_RANGE,
    VI_ZQ,
    VI_W
};

/* THIS FILE WAS GENERATED!
 *
 * This file was generated by qmk json2c. You may or may not want to
 * edit it directly.
 */

const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {
    [_BASE] = LAYOUT_split_3x6_3(_______,   KC_W, KC_L, KC_Y, KC_P, KC_B,        KC_Z, KC_F, KC_O, KC_U, KC_DQT, MO(_SYS),
                                 QK_LLCK,   KC_C, KC_R, KC_S, KC_T, KC_G,        KC_M, KC_N, KC_E, KC_I, KC_A,   QK_LLCK,
                                 TG(_MOUSE),KC_Q, KC_J, KC_V, KC_D, KC_K,        KC_X, KC_H, KC_COMM, KC_DOT, KC_QUES, DF(_GAME),
                                            KC_ESC, LT(_NAV, KC_SPC), ALT_T(KC_TAB),  OSM(MOD_LSFT),   CTL_T(KC_BSPC), GUI_T(KC_ENT)),

    [_GAME] = LAYOUT_split_3x6_3(KC_ESC, KC_W, KC_L, KC_Y, KC_P, KC_B,       KC_Z, KC_F, KC_O, KC_U, KC_DQT, MO(_SYS),
                                 KC_P3, KC_C, KC_R, KC_S, KC_T, KC_G,        KC_M, GUI_T(KC_N), LALT_T(KC_E), CTL_T(KC_I), KC_A, QK_LLCK,
                                 KC_TAB,  KC_Q, KC_J, KC_V, KC_D, KC_K,       KC_X, KC_H, KC_COMM, KC_DOT, KC_QUES, DF(_BASE),
                                                     KC_P1, LT(_NAV, KC_SPC),  LSFT_T(KC_P2),  LT(_MOUSE, KC_TAB),  LT(_NAV, KC_BSPC), KC_ENT),

    [_NAV] = LAYOUT_split_3x6_3(_______, G(KC_X), C(KC_U), C(KC_D), C(KC_P), _______,     VI_WQA,  KC_P7, KC_P8, KC_P9, OSM(MOD_RGUI), _______,
                                _______, KC_LEFT, KC_UP, KC_DOWN, KC_RIGHT, _______,      KC_P0,   KC_P4, KC_P5, KC_P6, OSM(MOD_RALT), _______,
                                _______, G(KC_A), KC_PGUP, KC_PGDN, C(KC_N),  VI_W,       VI_ZQ,   KC_P1, KC_P2, KC_P3, OSM(MOD_RCTL), _______,
                                                           _______, _______,  _______,     _______, _______, _______),

    [_MOUSE] = LAYOUT_split_3x6_3(_______, _______, _______, MS_UP, _______, OSM(MOD_LGUI),   _______, _______, MS_WHLU, _______, _______, _______,
                                  _______, _______, MS_LEFT, MS_DOWN, MS_RGHT, OSM(MOD_LALT), _______, MS_WHLL, MS_WHLD, MS_WHLR, _______, _______,
                                  _______, _______, KC_VOLD, KC_MUTE, KC_VOLU, OSM(MOD_LCTL),   _______, MS_ACL1, MS_ACL0, MS_ACL2, _______, _______,
                                                           MS_BTN3, MS_BTN1,  MS_BTN2,     _______, _______, _______),

    [_SYS] = LAYOUT_split_3x6_3(QK_BOOT, _______, _______, _______, _______, _______,       RM_VALU, RM_HUEU, RM_SATU, RM_NEXT, RM_TOGG, QK_BOOT,
                                _______,  _______, _______, _______, _______, _______,      RM_VALD, RM_HUED, RM_SATD, RM_PREV, CK_TOGG, _______,
                                _______, _______,  _______, _______, _______, _______,      _______, _______, _______, _______, _______, _______,
                                                           _______, _______, _______,       _______, _______, _______)
};

const char chordal_hold_layout[MATRIX_ROWS][MATRIX_COLS] PROGMEM =
    LAYOUT(
        'L', 'L', 'L', 'L', 'L', 'L',  'R', 'R', 'R', 'R', 'R', 'R',
        'L', 'L', 'L', 'L', 'L', 'L',  'R', 'R', 'R', 'R', 'R', 'R',
        'L', 'L', 'L', 'L', 'L', 'L',  'R', 'R', 'R', 'R', 'R', 'R',
                       '*', '*', '*',  '*', '*', '*'
    );


// Alt + Backspace = Del
const key_override_t delete_key_override = ko_make_basic(MOD_MASK_ALT, CTL_T(KC_BSPC), KC_DEL);
// Shift + " = '
const key_override_t quote_override = ko_make_basic(MOD_MASK_SHIFT, KC_DQT, KC_QUOT);
// Shift + . = :
const key_override_t dot_colon_override = ko_make_basic(MOD_MASK_SHIFT, KC_DOT, KC_COLN);
// Shift + , = ;
const key_override_t comma_semicolon_override = ko_make_basic(MOD_MASK_SHIFT, KC_COMM, KC_SCLN);
// Shift + ? = !
const key_override_t question_exclamation_override = ko_make_basic(MOD_MASK_SHIFT, KC_QUES, KC_EXLM);
// Shift + = = !
const key_override_t equal_exclamation_override = ko_make_basic(MOD_MASK_SHIFT, KC_PEQL, KC_EXLM);
// Shift + - = +
const key_override_t minus_plus_override = ko_make_basic(MOD_MASK_SHIFT, KC_PMNS, KC_PPLS);
// Shift + / = *
const key_override_t fslash_asterisk_override = ko_make_basic(MOD_MASK_SHIFT, KC_KP_SLASH, KC_ASTR);
// Shift + _ = ^
const key_override_t under_super_override = ko_make_basic(MOD_MASK_SHIFT, KC_UNDS, KC_CIRC);
// Shift + < = [
const key_override_t lt_sqopen_override = ko_make_basic(MOD_MASK_SHIFT, KC_LT, KC_LBRC);
// Shift + > = ]
const key_override_t gt_sqclose_override = ko_make_basic(MOD_MASK_SHIFT, KC_GT, KC_RBRC);

// Shift + @ = %]
const key_override_t at_percent_override = ko_make_basic(MOD_MASK_SHIFT, KC_AT, KC_PERC);
// Shift + & = |]
const key_override_t and_or_override = ko_make_basic(MOD_MASK_SHIFT, KC_AMPR, KC_PIPE);
// Shift + # = $]
const key_override_t hash_dollar_override = ko_make_basic(MOD_MASK_SHIFT, KC_HASH, KC_DLR);

const key_override_t *key_overrides[] = {
    &delete_key_override,
    &quote_override,
    &dot_colon_override,
    &comma_semicolon_override,
    &question_exclamation_override,
    &equal_exclamation_override,
    &minus_plus_override,
    &fslash_asterisk_override,
    &under_super_override,
    &lt_sqopen_override,
    &gt_sqclose_override,
    &at_percent_override,
    &and_or_override,
    &hash_dollar_override
};

#ifdef COMBO_MUST_TAP_PER_COMBO
bool get_combo_must_tap(uint16_t combo_index, combo_t *combo) {
    // If you want all combos to be tap-only, just uncomment the next line
    return true;
}
#endif

// bool remember_last_key_user(uint16_t keycode, keyrecord_t* record,
//                             uint8_t* remembered_mods) {
//     switch (keycode) {
//         case KC_A ... KC_Z:
//             if ((*remembered_mods & ~MOD_MASK_SHIFT) == 0) {
//                 *remembered_mods &= ~MOD_MASK_SHIFT;
//             }
//             break;
//         case MAGIC_REPEAT:
//             return false;
//     }
//     return true;  // Other keys can be repeated.
// }
//
// uint16_t get_alt_repeat_key_keycode_user(uint16_t keycode, uint8_t mods) {
//     switch (keycode) {
//         case MS_WHLU: return MS_WHLD;
//         case MS_WHLD: return MS_WHLU;
//         case KC_ASTR: return KC_HASH;
//         case KC_BSPC: return KC_DEL;
//         case KC_KP_SLASH: return KC_ASTR;
//         case KC_KP_ASTERISK: return KC_HASH;
//         case KC_HASH: return KC_KP_ASTERISK;
//         case KC_DOT: return M_UPDIR;
//         case KC_TAB:
//             {
//                 bool shifted = (mods & MOD_MASK_SHIFT);
//                 if (shifted) {        // If the last key was Shift + Tab,
//                     return KC_TAB;    // ... the reverse is Tab.
//                 } else {              // Otherwise, the last key was Tab,
//                     return S(KC_TAB); // ... and the reverse is Shift + Tab.
//                 }
//             }
//     }
//     return KC_TRNS;
// }

bool combo_should_trigger(uint16_t combo_index, combo_t *combo, uint16_t keycode, keyrecord_t *record) {
    if (layer_state_is(_MOUSE)) {
        return false;
    }
    return true;
}

bool process_record_user(uint16_t keycode, keyrecord_t *record) {
    switch (keycode) {
        // case MAGIC_REPEAT:
        //     if (record->tap.count) {
        //         uint8_t mod_state = get_mods();
        //         if (mod_state & MOD_MASK_SHIFT) {
        //             del_mods(MOD_MASK_SHIFT);
        //             alt_repeat_key_invoke(&record->event);
        //             set_mods(mod_state);
        //         } else {
        //             repeat_key_invoke(&record->event);
        //         }
        //         return false;
        //     }
        //     return true;
        // case M_UPDIR:
        //     if (record->event.pressed) {
        //         SEND_STRING("./");
        //     }
        //     return false;
        case VI_W:
            if (record->event.pressed) {
                SEND_STRING(":w\n"); return true;
            }
            return false;
        case VI_WQA:
            if (record->event.pressed) {
                SEND_STRING(":wqa\n"); return true;
            }
            return false;
        case VI_ZQ:
            if (record->event.pressed) {
                SEND_STRING("ZQ"); return true;
            }
            return false;
    }
    return true; // Return true to allow QMK to process the key as normal (though in this case, we've replaced its behavior)
};

#ifdef OLED_ENABLE
bool oled_task_user(void) {
  if (is_keyboard_master()) {
    oled_render_anim();
  } else {
    render_layer_state();
  }
  return false;
}
#endif

bool rgb_matrix_indicators_advanced_user(uint8_t led_min, uint8_t led_max) {
    if (host_keyboard_led_state().caps_lock) {
        for (uint8_t i = led_min; i < led_max; i++) {
            if (g_led_config.flags[i] & LED_FLAG_KEYLIGHT) {
                rgb_matrix_set_color(i, RGB_RED);
            }
        }
    }
    if (get_highest_layer(layer_state) > 0) {
        uint8_t layer = get_highest_layer(layer_state);

        for (uint8_t row = 0; row < MATRIX_ROWS; ++row) {
            for (uint8_t col = 0; col < MATRIX_COLS; ++col) {
                uint8_t index = g_led_config.matrix_co[row][col];

                if (index >= led_min && index < led_max && index != NO_LED &&
                keymap_key_to_keycode(layer, (keypos_t){col,row}) > KC_TRNS) {
                    rgb_matrix_set_color(index, RGB_CORAL);
                }
            }
        }
    }
    return false;
}
