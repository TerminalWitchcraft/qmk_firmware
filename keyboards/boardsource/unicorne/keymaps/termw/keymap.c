#include QMK_KEYBOARD_H
#include "g/keymap_combo.h"
#if __has_include("keymap.h")
    #include "keymap.h"
#endif

#define ANIM_INVERT false
#define ANIM_RENDER_WPM true
#define FAST_TYPE_WPM 40 //Switch to fast animation when over words per minute
#ifdef OLED_ENABLE
#include "demon.c"
#endif

#define _BASE 0
#define _NAV 1
#define _SYS 2

enum custom_keycodes {
    MAGIC_SHIFT = SAFE_RANGE,
    FENCED_CB,
    M_UPDIR
};


/* THIS FILE WAS GENERATED!
 *
 * This file was generated by qmk json2c. You may or may not want to
 * edit it directly.
 */

const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {
    [_BASE] = LAYOUT_split_3x6_3(KC_TAB, KC_W, KC_L, KC_Y, KC_P, KC_B,                                 KC_Z, KC_F, KC_O, KC_U, KC_QUOT, MO(_SYS),
                                 CW_TOGG, KC_C, CTL_T(KC_R), OPT_T(KC_S), GUI_T(KC_T), KC_G,          KC_M, GUI_T(KC_N), OPT_T(KC_E), CTL_T(KC_I), KC_A, KC_SCLN,
                                 KC_LSFT, KC_Q, KC_J, KC_V, KC_D, KC_K,                                KC_X, KC_H, KC_COMM, KC_DOT, KC_QUES, KC_ESC,
                                           KC_TAB, LT(_NAV, KC_SPC), KC_ESC, KC_ENT, LT(_NAV, KC_BSPC), RSFT_T(MAGIC_SHIFT)),

    [_NAV] = LAYOUT_split_3x6_3(_______, _______, KC_7, KC_8, KC_9, _______,     _______, _______, _______, _______, _______, _______,
                                _______, _______, KC_4, KC_5, KC_6, KC_0,        _______, KC_LEFT, KC_DOWN, KC_UP,  KC_RIGHT, _______,
                                _______, _______, KC_1, KC_2, KC_3, _______,     _______, _______, _______, _______, _______, _______,
                                                  _______, _______, _______,     _______, _______, _______),

    [_SYS] = LAYOUT_split_3x6_3(QK_BOOT, _______, _______, _______, _______, _______,       RM_VALU, RM_HUEU, RM_SATU, RM_NEXT, RM_TOGG, _______,
                                EE_CLR,  _______, _______, _______, _______, _______,       RM_VALD, RM_HUED, RM_SATD, RM_PREV, CK_TOGG, _______,
                                _______, _______, _______, _______, _______, _______,       _______, _______, _______, _______, _______, _______,
                                                           _______, _______, _______,       _______, _______, _______)
};


// Shift + esc = `
const key_override_t tilde_esc_override = ko_make_basic(MOD_MASK_SHIFT, KC_ESC, KC_GRV);
// GUI + esc = ~
const key_override_t grave_esc_override = ko_make_basic(MOD_MASK_GUI, KC_ESC, S(KC_GRV));
// Shift + TAB = ALT REP
const key_override_t shift_tab_override = ko_make_basic(MOD_MASK_SHIFT, KC_TAB, QK_AREP);
// Shift + . = :
const key_override_t dot_colon_override = ko_make_basic(MOD_MASK_SHIFT, KC_DOT, KC_COLN);
// Shift + , = ;
const key_override_t comma_semicolon_override = ko_make_basic(MOD_MASK_SHIFT, KC_COMM, KC_SCLN);
// Shift + ? = !
const key_override_t question_exclamation_override = ko_make_basic(MOD_MASK_SHIFT, KC_QUES, KC_EXLM);
// Shift + = = !
const key_override_t equal_exclamation_override = ko_make_basic(MOD_MASK_SHIFT, KC_PEQL, KC_EXLM);
// Shift + - = +
const key_override_t minus_plus_override = ko_make_basic(MOD_MASK_SHIFT, KC_PMNS, KC_PPLS);
// Shift + / = *
const key_override_t fslash_asterisk_override = ko_make_basic(MOD_MASK_SHIFT, KC_KP_SLASH, KC_ASTR);
// Shift + _ = ^
const key_override_t under_super_override = ko_make_basic(MOD_MASK_SHIFT, KC_UNDS, KC_CIRC);
// Shift + < = [
const key_override_t lt_sqopen_override = ko_make_basic(MOD_MASK_SHIFT, KC_LT, KC_LBRC);
// Shift + > = ]
const key_override_t gt_sqclose_override = ko_make_basic(MOD_MASK_SHIFT, KC_GT, KC_RBRC);

// Shift + @ = %]
const key_override_t at_percent_override = ko_make_basic(MOD_MASK_SHIFT, KC_AT, KC_PERC);
// Shift + & = |]
const key_override_t and_or_override = ko_make_basic(MOD_MASK_SHIFT, KC_AMPR, KC_PIPE);
// Shift + # = $]
const key_override_t hash_dollar_override = ko_make_basic(MOD_MASK_SHIFT, KC_HASH, KC_DLR);

const key_override_t *key_overrides[] = {
	&tilde_esc_override,
	&grave_esc_override,
    &shift_tab_override,
    &dot_colon_override,
    &comma_semicolon_override,
    &question_exclamation_override,
    &equal_exclamation_override,
    &minus_plus_override,
    &fslash_asterisk_override,
    &under_super_override,
    &lt_sqopen_override,
    &gt_sqclose_override,
    &at_percent_override,
    &and_or_override,
    &hash_dollar_override
};

bool should_repeat(uint16_t keycode) {
    switch (keycode) {
        case KC_A ... KC_Z:
        case KC_TAB:
        case KC_DOT:
        case KC_GRV:
        case KC_ASTR:
        case KC_HASH:
            return true;
    }
    return false;
}

uint16_t get_alt_repeat_key_keycode_user(uint16_t keycode, uint8_t mods) {
    switch (keycode) {
        case KC_GRV: return FENCED_CB;
        case KC_DOT: return M_UPDIR;
        case KC_TAB: return S(KC_TAB);
    }
    return KC_TRNS;
}

bool process_record_user(uint16_t keycode, keyrecord_t *record) {
    switch (keycode) {
        case MAGIC_SHIFT:
            // only customize the tap behavior
            // MAGIC_SHIFT is usually used with mod tap
            if (record->tap.count) {
                if (should_repeat(get_last_keycode())) {
                    // repeat key
                    tap_code16(QK_REP);
                } else {
                    // send sticky shift
                    tap_code16(OSM(MOD_RSFT));
                }
            }
            return false;
        case M_UPDIR: SEND_STRING(/*.*/"./"); return false;
        case FENCED_CB: SEND_STRING("``"); return false;
    }
    return true; // Return true to allow QMK to process the key as normal (though in this case, we've replaced its behavior)
};

#ifdef OLED_ENABLE
bool oled_task_user(void) {
  if (!is_keyboard_master()) {
    oled_render_anim();
  }
  return false;
}
#endif
